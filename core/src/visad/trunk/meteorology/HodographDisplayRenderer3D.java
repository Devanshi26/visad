// Generated by Together

package visad.meteorology;

import java.beans.PropertyChangeListener;
import java.util.Vector;
import javax.media.j3d.Appearance;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.ColoringAttributes;
import javax.media.j3d.LineArray;
import javax.media.j3d.Shape3D;
import javax.media.j3d.TransformGroup;
import javax.media.j3d.View;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.SwingPropertyChangeSupport;
import visad.CoordinateSystem;
import visad.Data;
import visad.Display;
import visad.DisplayRealType;
import visad.DisplayTupleType;
import visad.Real;
import visad.RealTuple;
import visad.SI;
import visad.Unit;
import visad.UnitException;
import visad.VisADException;
import visad.java3d.DefaultDisplayRendererJ3D;
import visad.java3d.VisADCanvasJ3D;


public class
HodographDisplayRenderer3D
    extends DefaultDisplayRendererJ3D
{
    /**
     * The pressure display-coordinate.
     */
    public static final DisplayRealType	PRESSURE;

    /**
     * The U-component of velocity display-coordinate.
     */
    public static final DisplayRealType	U;

    /**
     * The V-component of velocity display-coordinate.
     */
    public static final DisplayRealType	V;

    /**
     * The wind profile.
     */
    private WindProfileImpl		windProfile = null;

    /**
     * The unit of speed.
     */
    private static final Unit		SPEED_UNIT = CommonUnits.KNOT;

    /**
     * The maximum speed.
     */
    private static final float		MAX_SPEED = 10;

    /**
     * The unit of pressure.
     */
    private static final Unit		PRESSURE_UNIT = CommonUnits.PASCAL;

    /**
     * The minimum pressure.
     */
    private static final float		MIN_P = 10000f;

    /**
     * The maximum pressure.
     */
    private static final float		MAX_P = 105000f;

    /**
     * The hodograph coordinate-system transform.
     */
    private static final HodographCoordSys
					COORD_SYS;

    /**
     * The hodograph vector space.
     */
    private static final DisplayTupleType
					DISPLAY_TUPLE_TYPE;

    /**
     * Supports changes to cursor pressure.
     */
    private final SwingPropertyChangeSupport
					cursorPressureChanges;


    static
    {
	DisplayRealType		u = null;
	DisplayRealType		v = null;
	DisplayRealType		p = null;
	HodographCoordSys	coordSys = null;
	DisplayTupleType	displayTupleType = null;

	try
	{
	    u = new DisplayRealType("Hodograph3D_U", false, 0.0, SPEED_UNIT);
	    v = new DisplayRealType("Hodograph3D_V", false, 0.0, SPEED_UNIT);
	    p = new DisplayRealType("Hodograph3D_P", false, 0.0, PRESSURE_UNIT);
	    coordSys = new HodographCoordSys(
		MAX_SPEED, SPEED_UNIT, MIN_P, MAX_P, PRESSURE_UNIT);
	    displayTupleType = new DisplayTupleType(
		new DisplayRealType[] {u, v, p},
		coordSys);
	}
	catch (Exception e)
	{
	    String	reason = e.getMessage();
	    System.err.println(
		"Couldn't initialize class HodographDisplayRenderer3D" +
		(reason == null ? "" : ": " + reason));
	    e.printStackTrace();
	}

	U = u;
	V = v;
	PRESSURE = p;
	COORD_SYS = coordSys;
	DISPLAY_TUPLE_TYPE = displayTupleType;
    }


    /**
     * Constructs from nothing.
     */
    public
    HodographDisplayRenderer3D()
    {
	cursorPressureChanges = new SwingPropertyChangeSupport(this);
    }


    /**
     * Create scene graph root, if none exists, with Transform
     * and direct manipulation root.  Create 3-D box, lights and
     * MouseBehaviorJ3D for embedded user interface.
     */
    public BranchGroup
    createSceneGraph(View view, VisADCanvasJ3D canvas)
    {
	BranchGroup	root = super.createSceneGraph(view, canvas);
	TransformGroup	trans = getTrans();

	/*
	 * Add vertical line at (x,y) origin.
	 */
	LineArray		originAxisGeometry =
	    new LineArray(2, LineArray.COORDINATES);
	originAxisGeometry.setCoordinates(
	    0, new float[] {0f, 0f, -1f, 0f, 0f, 1f});
	Appearance		originAxisAppearance = new Appearance();
	ColoringAttributes	originAxisColor = new ColoringAttributes();
	originAxisColor.setCapability(ColoringAttributes.ALLOW_COLOR_READ);
	originAxisColor.setCapability(ColoringAttributes.ALLOW_COLOR_WRITE);
	originAxisColor.setColor(0f, 0.5f, 1f);
	originAxisAppearance.setColoringAttributes(originAxisColor);
	Shape3D			originAxis = 
	    new Shape3D(originAxisGeometry, originAxisAppearance);
	trans.addChild(originAxis);

	return root;
    }


    /**
     * Indicates whether or not the given display real type is legal
     * for this display renderer.
     *
     * @param type	The display real type to be vetted.
     * @return		<code>true</code> if and only if <code>type</code>
     *			is a legal display real type for this display
     * 			renderer.
     */
    public boolean
    legalDisplayScalar(DisplayRealType type)
    {
	return type.equals(U) ||
	    type.equals(V) ||
	    type.equals(PRESSURE) ||
	    super.legalDisplayScalar(type);
    }


    /**
     * Sets the wind profile currently being displayed (necessary to
     * extract wind values).
     * @param windProfile	The wind profile currently being displayed
     *				or <code>null</code> to disable wind value
     *				readouts.
     */
    public void
    setWindProfile(WindProfileImpl windProfile)
    {
	this.windProfile = windProfile;
    }


    /**
     * Gets the cursor coordinates.
     *
     * @return                  Cursor coordinates in display space.
     *
     * @param cursor            The location of the cursor in display
     *                          coordinates.
     */
    protected final double[][]
    getCursorCoords(double[] cursor)
    {
        return new double[][] {
            new double[] {cursor[0]}, 
            new double[] {cursor[1]}, 
            new double[] {cursor[2]}};
    }


    /**
     * Gets the pressure at the cursor position.
     * @return			The pressure at the cursor position
     *				or <code>null</code> if not available.
     */
    public Real
    getCursorPressure()
    {
	Real	value;
	try
	{
	    value = new Real(
		CommonTypes.PRESSURE, 
		COORD_SYS.fromReference(getCursorCoords(getCursor()))[2][0],
		COORD_SYS.getPressureUnit());
	}
	catch (Exception e)
	{
	    value = null;
	}
	return value;
    }


    /**
     * Gets the wind speed at the cursor position.
     * @return			The wind speed at the cursor position or
     *				<code>null</code> if not available.
     */
    public Real
    getCursorSpeed()
    {
	Real	value;
	try
	{
	    double[][]	velocities =
		COORD_SYS.fromReference(getCursorCoords(getCursor()));
	    double	u = velocities[0][0];
	    double	v = velocities[1][0];
	    value = new Real(
		CommonTypes.SPEED,
		Math.sqrt(u*u + v*v),
		COORD_SYS.getSpeedUnit());
	}
	catch (Exception e)
	{
	    value = null;
	}
	return value;
    }


    /**
     * Gets the wind direction at the cursor position.
     * @return			The wind direction at the cursor position or
     *				<code>null</code> if not available.
     */
    public Real
    getCursorDirection()
    {
	Real	value;
	try
	{
	    double[][]	velocities =
		COORD_SYS.fromReference(getCursorCoords(getCursor()));
	    double	u = velocities[0][0];
	    double	v = velocities[1][0];
	    double	dir = Math.atan2(-u, -v);
	    if (dir < 0)
		dir += 2*Math.PI;
	    value = new Real(
		CommonTypes.DIRECTION,
		dir,
		SI.radian);
	}
	catch (Exception e)
	{
	    value = null;
	}
	return value;
    }


    /**
     * Sets strings in the vector that describes the current location of the
     * cursor.
     */
    public void
    setCursorStringVector()
    {
	cursorPressureChanges.firePropertyChange(
	    "Pressure", null, getCursorPressure());
	setCursorStringVector(null);
    }


    /**
     * Adds a listener for changes to the cursor pressure.
     * @param listener		The change listener.
     */
    public void
    addCursorPressureChangeListener(PropertyChangeListener listener)
    {
	cursorPressureChanges.addPropertyChangeListener(listener);
    }


    /**
     * Get the speed at the canonical outer limit of the display.
     * @return			The speed at the canonical outer limit of the
     *				display.
     * @throws VisADException	Couldn't create necessary VisAD object.
     */
    public Real
    getMaximumSpeed()
	throws VisADException
    {
	return new Real(CommonTypes.SPEED, MAX_SPEED, SPEED_UNIT);
    }


    /**
     * Provides support for converting between hodograph coordinates
     * and display coordinates.
     */
    public static class
    HodographCoordSys
	extends	CoordinateSystem
    {
	private /*final*/ double	maxSpeed;
	private /*final*/ double	logMinP;
	private /*final*/ double	yPerLogP;


	/*
	 * Constructs from a maximum speed and unit and pressure limits and
	 * unit.
	 *
	 * @param maxSpeed		The maximum speed to display.  Will be 
	 *				mapped to a display radis of 1.
	 * @param speedUnit		The unit of speed.
	 * @param minPressure		The minimum pressure to display.  Will
	 *				be mapped to a display radius of 1.
	 * @param maxPressure		The maximum pressure to display.  Will
	 *				be mapped to a display radius of 1.
	 * @param pressureUnit		The unit of pressure.
	 * @throws VisADException	Couldn't create necessary VisAD object.
	 * @throws IllegalArgumentException
	 *				<code>maxSpeed <= 0 </code>.
	 */
	public
	HodographCoordSys(double maxSpeed, Unit speedUnit, double minPressure,
		double maxPressure, Unit pressureUnit)
	    throws VisADException
	{
	    super(Display.DisplaySpatialCartesianTuple,
		new Unit[] {speedUnit, speedUnit, pressureUnit});

	    if (maxSpeed <= 0 || minPressure >= maxPressure)
		throw new IllegalArgumentException();

	    this.maxSpeed = maxSpeed;
	    logMinP = Math.log(minPressure);
	    yPerLogP = (float)(-2 / (Math.log(maxPressure) - logMinP));
	}


	/**
	 * Converts from display coordinates to hodograph coordinates.
	 *
	 * @param coords		The coordinates.  On input, coords[0]
	 *				and coords[1] contain, respectively,
	 *				the X and Y display coordinates.  On
	 *				output, coords[0] and coords[1]
	 *				contain, respectively, the U and V
	 *				coordinates.
	 * @throws IllegalArgumentException
	 *				Invalid input coordinates: <code>coords
	 *				== null || coords.length < 3 ||
	 *				coords[0].length != coords[1].length ||
	 *				coords[0].length != coords[2].length
	 *				</code>.
	 */
	public double[][]
	fromReference(double[][] coords)
	{
	    if (coords == null || coords.length < 3 ||
		coords[0].length != coords[1].length ||
		coords[0].length != coords[2].length)
	    {
		throw new IllegalArgumentException(
		    "Invalid input coordinates");
	    }

	    double[]	xs = coords[0];		// also U
	    double[]	ys = coords[1];		// also V
	    double[]	ps = coords[2];		// also PRESSURE
	    int		npts = xs.length;

	    for (int i = 0; i < npts; ++i)
	    {
		xs[i] *= maxSpeed;	// U
		ys[i] *= maxSpeed;	// V
		ps[i] = Math.exp((ps[i] - 1) / yPerLogP + logMinP);	// P
	    }

	    return coords;
	}


	/**
	 * Converts from hodograph coordinates to display coordinates.
	 *
	 * @param coords		The coordinates.  On input, coords[0]
	 *				and coords[1] contain, respectively,
	 *				the U, V, and P coordinates.
	 *				On output, coords[0] and coords[1]
	 *				contain, respectively, the X, Y, and Z
	 *				display coordinates.
	 * @throws IllegalArgumentException
	 *				Invalid input coordinates:
	 *				<code>coords == null ||
	 *				coords.length < 3 ||
	 *				coords[0].length != coords[1].length ||
	 *				coords[0].length != coords[2].length
	 *				</code>.
	 */
	public double[][]
	toReference(double[][] coords)
	{
	    if (coords == null || coords.length < 3 ||
		coords[0].length != coords[1].length)
	    {
		throw new IllegalArgumentException("Invalid input coordinates");
	    }

	    double[]	us = coords[0];		// also X
	    double[]	vs = coords[1];		// also Y
	    double[]	ps = coords[2];		// also Z
	    int		npts = us.length;

	    for (int i = 0; i < npts; ++i)
	    {
		us[i] /= maxSpeed;	// X
		vs[i] /= maxSpeed;	// Y
		ps[i] = 1 + yPerLogP * (Math.log(ps[i]) - logMinP);	// Z
	    }

	    return coords;
	}


	/**
	 * Gets the unit of pressure.
	 */
	public Unit
	getPressureUnit()
	{
	    return getCoordinateSystemUnits()[2];
	}


	/**
	 * Gets the unit of speed.
	 */
	public Unit
	getSpeedUnit()
	{
	    return getCoordinateSystemUnits()[0];
	}


	/**
	 * Indicates whether this coordinate system equals an object.
	 *
	 * @param object	The object to be compared to this.
	 * @return		<code>true</code> if and only if this
	 *			coordinate system is semantically identical
	 *			to <code>object</code>.
	 */
	public boolean
	equals(Object object)
	{
	    boolean	equals;

	    if (!(object instanceof HodographCoordSys))
		equals = false;
	    else
	    {
		HodographCoordSys	that = (HodographCoordSys)object;
		equals = 
		    maxSpeed == that.maxSpeed &&
		    yPerLogP == that.yPerLogP &&
		    logMinP == that.logMinP;
	    }

	    return equals;
	}
    }
}
