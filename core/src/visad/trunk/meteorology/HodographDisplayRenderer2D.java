// Generated by Together

package visad.meteorology;

import visad.CoordinateSystem;
import visad.Display;
import visad.DisplayRealType;
import visad.DisplayTupleType;
import visad.Real;
import visad.SI;
import visad.Unit;
import visad.UnitException;
import visad.VisADException;
import visad.java2d.DefaultDisplayRendererJ2D;


public class
HodographDisplayRenderer2D
    extends DefaultDisplayRendererJ2D
{
    /**
     * The default unit of speed.
     */
    public static final Unit		DEFAULT_SPEED_UNIT = 
	CommonTypes.SPEED.getDefaultUnit();

    /**
     * The default maximum speed.
     */
    public static final float		DEFAULT_MAX_SPEED;


    static
    {
	float	defaultMaxSpeed = 0;

	try
	{
	    defaultMaxSpeed =
		(float)DEFAULT_SPEED_UNIT.toThis(100, CommonUnits.KNOT);
	}
	catch (UnitException e)
	{
	    String	reason = e.getMessage();

	    System.err.println(
		"Couldn't initialize class HodographDisplayRenderer2D" +
		(reason == null ? "" : (": " + reason)));
	}

	DEFAULT_MAX_SPEED = defaultMaxSpeed;
    }

    /**
     * The U-component of velocity.
     */
    public static final DisplayRealType	U;

    /**
     * The V-component of velocity.
     */
    public static final DisplayRealType	V;

    /**
     * The display Z axis (dummy -- but necessary).
     */
    private static final DisplayRealType
					Z;

    /**
     * The hodograph vector space.
     */
    private final DisplayTupleType	HODOGRAPH_SPACE;

    /**
     * The hodograph coodinate-system transform.
     */
    private final HodographCoordSys	HODOGRAPH_COORDSYS;


    static
    {
	DisplayRealType	u = null;
	DisplayRealType	v = null;
	DisplayRealType	z = null;

	try
	{
	    u = new DisplayRealType("Hodograph2DU", false, 
		0.0, DEFAULT_SPEED_UNIT);
	    v = new DisplayRealType("Hodograph2DV", false, 
		0.0, DEFAULT_SPEED_UNIT);
	    z = new DisplayRealType("Hodograph2DZ", false, 0.0, null);
	}
	catch (Exception e)
	{
	    String	reason = e.getMessage();

	    System.err.println(
		"Couldn't initialize HodographDisplayRenderer2D class" +
		(reason == null ? "" : ": " + reason));
	    e.printStackTrace();
	}

	U = u;
	V = v;
	Z = z;
    }


    /*
     * Constructs from a maximum speed and unit.
     *
     * @param maxSpeed		The maximum speed to display.  Will be mapped
     *				to a display radis of 1.
     * @param speedUnit		The unit of speed.
     * @throws VisADException	Couldn't create necessary VisAD object.
     */
    public
    HodographDisplayRenderer2D(double maxSpeed, Unit speedUnit)
	throws VisADException
    {
	HODOGRAPH_COORDSYS = new HodographCoordSys(maxSpeed, speedUnit);
	HODOGRAPH_SPACE = new DisplayTupleType(
	    new DisplayRealType[] {U, V, Z},
	    HODOGRAPH_COORDSYS);
    }


    /**
     * Constructs from nothing.  Will use DEFAULT_MAX_SPEED, and
     * DEFAULT_SPEED_UNIT.
     *
     * @throws VisADException	Couldn't create necessary VisAD object.
     */
    public
    HodographDisplayRenderer2D()
	throws VisADException
    {
	this(DEFAULT_MAX_SPEED, DEFAULT_SPEED_UNIT);
    }


    /**
     * Provides support for converting between hodograph coordinates
     * and display coordinates.
     */
    public class
    HodographCoordSys
	extends	CoordinateSystem
    {
	private final double	maxSpeed;


	/*
	 * Constructs from a maximum speed and unit for speed.
	 *
	 * @param maxSpeed		The maximum speed to display.  Will be 
	 *				mapped to a display radis of 1.
	 * @param speedUnit		The unit of speed.
	 * @throws VisADException	Couldn't create necessary VisAD object.
	 * @throws IllegalArgumentException
	 *				<code>maxSpeed <= 0 </code>.
	 */
	public
	HodographCoordSys(double maxSpeed, Unit speedUnit)
	    throws VisADException
	{
	    super(Display.DisplaySpatialCartesianTuple,
		new Unit[] {speedUnit, speedUnit, null});

	    if (maxSpeed <= 0)
		throw new IllegalArgumentException();

	    this.maxSpeed = maxSpeed;
	}


	/**
	 * Converts from display coordinates to hodograph coordinates.
	 *
	 * @param coords		The coordinates.  On input, coords[0]
	 *				and coords[1] contain, respectively,
	 *				the X and Y display coordinates.  On
	 *				output, coords[0] and coords[1]
	 *				contain, respectively, the U and V
	 *				coordinates.
	 * @throws IllegalArgumentException
	 *				Invalid input coordinates: <code>coords
	 *				== null || coords.length < 2 ||
	 *				coords[0].length != coords[1].length
	 *				</code>.
	 */
	public double[][]
	fromReference(double[][] coords)
	{
	    if (coords == null || coords.length < 2 ||
		coords[0].length != coords[1].length)
	    {
		throw new IllegalArgumentException("Invalid input coordinates");
	    }

	    double[]	xs = coords[0];
	    double[]	ys = coords[1];
	    int		npts = xs.length;

	    for (int i = 0; i < npts; ++i)
	    {
		xs[i] *= maxSpeed;	// U
		ys[i] *= maxSpeed;	// V
	    }

	    return coords;
	}


	/**
	 * Converts from hodograph coordinates to display coordinates.
	 *
	 * @param coords		The coordinates.  On input, coords[0]
	 *				and coords[1] contain, respectively,
	 *				the U and V coordinates.
	 *				On ouput, coords[0] and coords[1]
	 *				contain, respectively, the X and Y
	 *				display coordinates.
	 * @throws IllegalArgumentException	Invalid input coordinates:
	 *					<code>coords == null ||
	 *					coords.length < 2 ||
	 *					coords[0].length != 
	 *					coords[1].length</code>.
	 */
	public double[][]
	toReference(double[][] coords)
	{
	    if (coords == null || coords.length < 2 ||
		coords[0].length != coords[1].length)
	    {
		throw new IllegalArgumentException("Invalid input coordinates");
	    }

	    double[]	us = coords[0];
	    double[]	vs = coords[1];
	    int		npts = us.length;

	    for (int i = 0; i < npts; ++i)
	    {
		us[i] /= maxSpeed;	// X
		vs[i] /= maxSpeed;	// Y
	    }

	    return coords;
	}


	/**
	 * Indicates whether this coordinate system equals an object.
	 *
	 * @param object	The object to be compared to this.
	 * @return		<code>true</code> if and only if this
	 *			coordinate system is semantically identical
	 *			to <code>object</code>.
	 */
	public boolean
	equals(Object object)
	{
	    boolean	equals;

	    if (!(object instanceof HodographCoordSys))
		equals = false;
	    else
	    {
		HodographCoordSys	that = (HodographCoordSys)object;

		equals = maxSpeed == that.maxSpeed;
	    }

	    return equals;
	}
    }
}
